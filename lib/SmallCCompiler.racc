class MyParser

rule
    program                     : external_declaration
                                | program external_declaration {result = val}
                                
    external_declaration        : declaration
                                | function_prototype
                                | function_definition
                                
    declaration                 : type_specifier declarator_list ';' {result = val}
                                
    declarator_list             : declarator
                                | declarator_list ',' declarator {result = val}
                                
    declarator                  : direct_declarator
                                | '*' direct_declarator {result = val}
                                
    direct_declarator           : IDENTIFIER
                                | IDENTIFIER '[' CONSTANT ']' {result = val}
                                
    function_prototype          : type_specifier function_declarator ';' {result = val}
                                
    function_declarator         : IDENTIFIER '(' parameter_type_listopt ')' {result = val}
                                | '*' IDENTIFIER '(' parameter_type_listopt ')' {result = val}
                                
    function_definition         : type_specifier function_declarator compound_statement {result = val}
                                
    parameter_type_list         : parameter_declaration
                                | parameter_type_list ',' parameter_declaration {result = val}
    parameter_declaration       : type_specifier parameter_declarator {result = val}
                                
    parameter_declarator        : IDENTIFIER
                                | '*' IDENTIFIER {result = val}
                                
    type_specifier              : INT
                                | VOID
                                
    statement                   : ';'
                                | expression ';' {result = val}
                                | compound_statement
                                | IF '(' expression ')' statement {result = val}
                                | IF '(' expression ')' statement ELSE statement {result = val}
                                | WHILE '(' expression ')' statement {result = val}
                                | FOR '(' expressionopt ';' expressionopt ';' expressionopt ')' statement {result = val}
                                | RETURN expressionopt ';' {result = val}
                                
    compound_statement          : '{' declaration_listopt statement_listopt '}' {result = val}
                                
    declaration_list            : declaration
                                | declaration_list declaration {result = val}
                                
    statement_list              : statement
                                | statement_list statement {result = val}
                                
    expression                  : assign_expr
                                | expression ',' assign_expr {result = val}
                                
    assign_expr                 : logical_OR_expr
                                | logical_OR_expr '=' assign_expr {result = val}
                                
    logical_OR_expr             : logical_AND_expr
                                | logical_OR_expr  '||' logical_AND_expr {result = val}
                                
    logical_AND_expr            : equality_expr
                                | logical_AND_expr  '&&' equality_expr {result = val}
                                
    equality_expr               : relational_expr
                                | equality_expr  '==' relational_expr {result = val}
                                | equality_expr  '!=' relational_expr {result = val}
                                
    relational_expr             : add_expr
                                | relational_expr  '<' add_expr {result = val}
                                | relational_expr  '>' add_expr {result = val}
                                | relational_expr  '<=' add_expr {result = val}
                                | relational_expr  '>=' add_expr {result = val}
                                
    add_expr                    : mult_expr
                                | add_expr '+' mult_expr {result = val}
                                | add_expr '-' mult_expr {result = val}
                                
    mult_expr                   : unary_expr
                                | mult_expr '*' unary_expr {result = val}
                                | mult_expr '/' unary_expr {result = val}
                                
    unary_expr                  : postfix_expr
                                | '_' unary_expr {result = val}
                                | '&' unary_expr {result = val}
                                | '*' unary_expr {result = val}
                                
    postfix_expr                : primary_expr
                                | postfix_expr  '[' expression ']' {result = val}
                                | IDENTIFIER  '(' argument_expression_listopt ')' {result = val}
                                
    primary_expr                : IDENTIFIER
                                | CONSTANT
                                | '(' expression ')' {result = val}
                                
    argument_expression_list    : assign_expr
                                | argument_expression_list ',' assign_expr {result = val}
                                
    parameter_type_listopt      : parameter_type_list
                                |
                                
    expressionopt               : expression
                                |
                                
    declaration_listopt         : declaration_list
                                |
                                
    statement_listopt           : statement_list
                                |

    argument_expression_listopt : argument_expression_list
                                |

end

---- header ----
require 'pry'
require 'SmallCCompiler/small_c.rex'
require 'SmallCCompiler/nodes'

---- inner ----
def to_tokens
  if ARGV[0]
    filename = ARGV[0]
  else
    print 'Enter filename: '
    filename = gets.strip
  end
  rex = Sample.new
  tokens = []
  begin
    rex.load_file filename
    while token = rex.next_token
      tokens << token
    end
    return tokens
  rescue
    $stderr.printf "error"
  end
end

def parse
  @tokens = to_tokens
  do_parse
end

def next_token
  @tokens.shift
end

---- footer ----

if __FILE__ == $0
  parser = MyParser.new

  begin
    Pry::ColorPrinter.pp parser.parse
  rescue Racc::ParseError => e
    $stderr.puts e, e.backtrace
  end
end
